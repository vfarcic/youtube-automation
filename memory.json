{"type":"entity","name":"YouTube Automation Tool","entityType":"Project","observations":["A Go-based command-line tool for automating YouTube video publishing workflow","Features include: YouTube video uploads with metadata, Hugo blog integration, Bluesky social media posting","Configuration via settings.yaml file and environment variables","Key files: main.go, cli.go, youtube.go, email.go, hugo.go, bluesky.go"]}
{"type":"entity","name":"Project Config","entityType":"Configuration","observations":["Uses settings.yaml with sections for email, AI, YouTube, Hugo, and Bluesky","Sensitive data can use environment variables: EMAIL_PASSWORD, AI_KEY, YOUTUBE_API_KEY, BLUESKY_PASSWORD","Required flags include email settings, AI settings (Azure OpenAI), YouTube API key, and Hugo path","Optional flags for Bluesky integration"]}
{"type":"entity","name":"Project Requirements","entityType":"Dependencies","observations":["Go 1.x","YouTube API credentials (client_secret.json)","Azure OpenAI API key","Email account for notifications","Optional: Hugo site repository","Optional: Bluesky account"]}
{"type":"entity","name":"Git Workflow Rule","entityType":"Process","observations":["When pushing changes to Git, add a list of completed Taskmaster tasks to the PR description","Mark tasks as 'done' in the PR description that have been completed in the current work","Always include task IDs and titles for clear tracking of completed work","This provides better visibility into what each PR accomplishes"]}
{"type":"entity","name":"Charmbracelet Libraries","entityType":"UI Framework","observations":["The YouTube Automation project uses Charmbracelet libraries for its terminal UI components","Uses 'huh' library for interactive forms and confirmation dialogs","Uses 'lipgloss' for terminal styling and text formatting","Part of the confirmation utility implementation in pkg/utils/confirmation.go","Provides a consistent and user-friendly terminal UI experience"]}
{"type":"entity","entityType":"TestingGuideline","name":"MockingStrategy","observations":["Avoid doing mock except when working with external APIs.","Focus on integration tests with temporary files and actual file system operations where possible for non-external API interactions."]}
{"type":"entity","observations":["The project is written in Go.","The project is hosted on GitHub.","The `gh` CLI can be used for GitHub command-line operations.","The `github` MCP toolset can be used for interacting with the GitHub API."],"name":"youtube-automation","entityType":"Project"}
{"type":"entity","entityType":"ProjectPreference","name":"DefaultPRBaseBranch","observations":["When creating pull requests for the `youtube-automation` project, the default base branch to merge into should be `main`."]}
{"type":"entity","name":"PullRequestWorkflow","observations":["When a pull request (PR) is created based on work stemming from a GitHub Issue labeled `PRD` (which serves as the Product Requirement Document):","The PR description MUST include a direct link to the originating PRD GitHub Issue.","The local Taskmaster task files (i.e., `tasks/tasks.json` and all individual markdown files in the `tasks/` directory), which were generated from the PRD GitHub Issue for local development, should be REMOVED from the local file system. (Note: These files are in `.gitignore` and their removal is a local cleanup, not part of the PR's diff - see `TasksDirectoryHandling`)."],"entityType":"DevelopmentProcessGuideline"}
{"type":"entity","observations":["The `tasks/` directory and its contents are listed in `.gitignore`.","When removing task files as part of a workflow (like PR finalization):","1. Remove ALL files from the `tasks/` directory using `rm -rf tasks/*` or `rm -f tasks/*` (if you want to be prompted for directories). Be cautious with `rm -rf`.","2. This is a local filesystem change, not a staged `git rm` action, due to `.gitignore`."],"name":"TasksDirectoryHandling","entityType":"ProjectConfiguration"}
{"type":"entity","name":"DefaultPRMergeStrategy","observations":["When merging pull requests for the `youtube-automation` project, the default strategy should be to SQUASH and merge."],"entityType":"ProjectPreference"}
{"type":"entity","entityType":"DevelopmentProcessGuideline","name":"PrePRMergeChecklist","observations":["Before attempting to merge a pull request:","1. Always check for uncommitted local changes or modified tracked files using `git status`.","2. Ensure these are either committed, stashed, or intentionally excluded before proceeding with the merge operation."]}
{"type":"entity","name":"CommitMessageSuggestion","observations":["When new changes are staged for a commit, always suggest a commit message rather than asking the user to provide one. The suggestion should be based on the nature of the staged files and changes."],"entityType":"DevelopmentProcessGuideline"}
{"type":"entity","observations":["When presenting the user with choices or alternative actions, always format them as a numbered list to make it easier for the user to indicate their selection."],"name":"NumberedOptionsForChoices","entityType":"CommunicationStyleGuideline"}
{"type":"entity","entityType":"Guideline","observations":["Always run all tests after making code changes to confirm the changes work correctly."],"name":"Post-Change Testing Guideline"}
{"type":"entity","name":"Post-Change Compilation Guideline","entityType":"Guideline","observations":["Always compile the code to verify that it works."]}
{"type":"entity","name":"Coverage Tracking Method Guideline","entityType":"Guideline","observations":["Before initiating any code modifications or applying suggested edits (e.g., immediately before calling `edit_file` or starting manual coding), always generate a baseline coverage profile using `go test -coverprofile=coverage_before.out ./...`. After changes are successfully applied and all tests pass, generate the subsequent profile using `go test -coverprofile=coverage_after.out ./...`. Comparison should then be done manually (e.g., using `go tool cover -html=<filename>`)."]}
{"type":"entity","name":"EndOfSessionGitPushTrigger","entityType":"DevelopmentProcessGuideline","observations":["When the user indicates completion with a phrase like 'We are done', initiate the Git push process: 1. Check `git status`. 2. If there are uncommitted changes, ask the user how to handle them (stage all, stage specific, discard). 3. If changes are staged or need staging, suggest a commit message and ask for confirmation before committing. 4. Before pushing to `main` (or merging to `main`), execute the pre-push build checks defined in `MandatoryDevboxBuildBeforeMain`. 5. Check `.cursor/mcp.json` for sensitive keys as per `MCPKeyHandlingForGitPush`. 6. If all checks pass and the repository is ready, execute `git push`. If any step fails or requires user input, pause and ask for instructions."]}
{"type":"entity","name":"Test-Driven Development","observations":["ACTION REQUIRED: YOU MUST APPLY Test-Driven Development (TDD) for all code changes in this project.","FIRST STEP: Before proposing *any* code modification (e.g., via `edit_file`) or writing implementation code, ALWAYS write the necessary test(s) first.","TDD CYCLE: Follow the Red-Green-Refactor cycle (Write failing test -> Write code to pass -> Refactor).","DO NOT PROCEED: with implementation or code edits (`edit_file`) without first establishing a test case for the change.","TDD is a software development approach where tests are written before the code implementation.","Benefits include better design, higher code quality, built-in regression testing, and clear specification of requirements.","**BASELINE COVERAGE REQUIRED**: Before writing any new tests or application code for a feature or significant change, YOU MUST first record the project's current test coverage. Use the project-specific command (e.g., `go test ./... -cover` for Go projects). Log this baseline coverage figure. This step is critical for understanding the impact of new tests and changes.","CRITICAL WORKFLOW STEP: Immediately after parsing a PRD and *before* identifying or starting the first task that involves writing tests or application code (as per TDD), ALWAYS run and record the baseline test coverage using the project-specific command (e.g., `go test ./... -cover` for Go). Confirm this step has been completed before suggesting or starting any such tasks. This step is critical for understanding the impact of new tests and changes."],"entityType":"Development Principle"}
{"type":"entity","observations":["**ACTION REQUIRED**: When proposing a `git push`, first check `git status`. If there are uncommitted changes (modified or untracked files), propose staging and committing *all* of them before suggesting the push command. Do not propose `git push` if uncommitted changes exist unless the user explicitly instructs otherwise."],"name":"SuggestPushAllChangesGuideline","entityType":"DevelopmentProcessGuideline"}
{"type":"entity","entityType":"DevelopmentProcessGuideline","name":"MandatoryDevboxBuildBeforeMain","observations":["**ACTION REQUIRED**: Before executing `git push` to the `main` branch (or merging any branch into `main`), YOU MUST build the binary using `go build -o youtube-release` and make it executable using `chmod +x youtube-release`. Do not proceed with the push/merge until this build completes successfully. **REMINDER:** After the build succeeds, if you want to install this new version globally, **you need to manually run `sudo mv youtube-release /usr/local/bin`**. This installation step is manual and requires `sudo`."]}
{"type":"entity","name":"PRDHandlingGuideline","observations":["Product Requirement Documents (PRDs) are to be created and managed as GitHub Issues.","GitHub Issues representing PRDs MUST be labeled with `PRD` for easy identification and filtering.","Developers will typically fetch GitHub Issues labeled `PRD` from1 GitHub to select a requirement to work on.","Local Taskmaster tasks are expected to be generated or created based on the content of the selected PRD GitHub Issue to guide local development.","When a new PRD is to be created, it MUST be created as a GitHub Issue in the relevant repository, labeled with 'PRD'. The AI assistant should use the `mcp_github_create_issue` tool for this purpose."],"entityType":"DevelopmentProcessGuideline"}
{"type":"entity","name":"GitHubCLIGuideline","observations":["When performing operations with the GitHub platform (e.g., creating issues, managing pull requests, fetching repository data), the `github` MCP toolset SHOULD be used as the primary method if a suitable tool exists for the operation.","Using the `github` MCP toolset promotes integration with the AI assistant's capabilities and leverages structured tooling.","For GitHub operations not covered by the `github` MCP toolset, or for complex scripting, the `gh` command-line interface (CLI) tool can be used as a secondary option.","Local Git repository management (e.g., `git commit`, `git push`, `git branch`) should still be performed using `git` CLI commands, as distinct from GitHub platform interactions."],"entityType":"DevelopmentProcessGuideline"}
{"type":"entity","name":"Get PRDs","entityType":"UserIntent","observations":["User wants to work with Taskmaster and GitHub issues labeled PRD."]}
{"type":"entity","observations":["A tool for managing software development projects."],"name":"Taskmaster","entityType":"Tool"}
{"type":"entity","entityType":"DataSource","observations":["These issues are used as Product Requirement Documents."],"name":"GitHub Issues with PRD label"}
{"type":"entity","entityType":"DevelopmentProcessGuideline","name":"PRDIssueClosureSync","observations":["When a set of Taskmaster tasks derived from1 a PRD (Product Requirement Document, which is a GitHub Issue labeled 'PRD') is considered complete or closed, the original GitHub Issue that served as the PRD should also be closed on GitHub."]}
{"type":"entity","entityType":"DevelopmentProcessGuideline","observations":["When a PRD (GitHub Issue labeled 'PRD') is selected to be worked on (e.g., tasks are generated from1 it), update the GitHub Issue to reflect its active status.","This update should typically be a comment on the issue, for example: 'Work started on this PRD on YYYY-MM-DD. Tasks have been generated in the local Taskmaster setup.'","This ensures that when PRDs are listed or viewed, their active status is apparent directly on GitHub.","Use the `mcp_github_add_issue_comment` tool to add this comment, providing the issue number and body."],"name":"PRDWorkStatusUpdateGuideline"}
{"type":"entity","entityType":"Procedure","name":"PRD Closure Process","observations":["Defines the steps to take when a Product Requirements Document (PRD) is declared closed by the user.","When a PRD is closed, all code changes should be pushed to the current working Git branch.","After pushing changes for a closed PRD, a Pull Request (PR) should be created from the working branch to the main branch.","Once the Pull Request for a closed PRD is created (and presumably approved/passes checks), it should be merged into the main branch.","The GitHub issue corresponding to the closed PRD should be updated with information about the merged Pull Request (e.g., a link).","After updating the GitHub issue with the PR information, the GitHub issue itself should be closed.","This entire process (push, PR creation, PR merge, issue update, issue close) is initiated when the user states a PRD is closed.","When creating the Pull Request for a closed PRD, the description or body of the Pull Request should reference the GitHub issue that corresponds to the PRD (e.g., by including 'Closes #issue_number' or 'Fixes #issue_number').","Before pushing any changes for a closed PRD, all new and modified files relevant to the PRD must be staged using a command like `git add .`.","After staging, the changes must be committed with a descriptive message that clearly indicates the completion of the PRD (e.g., using 'feat: ... (PRD #number)' or similar).","The steps of staging and committing changes should occur *before* pushing the branch to the remote repository as part of the PRD closure.","After the Pull Request for a closed PRD has been successfully merged into the main branch, the local working Git branch should be deleted.","Following the deletion of the local branch, the corresponding remote Git branch should also be deleted from the repository.","A critical precondition for starting the PRD closure process is to verify that all Task Master tasks associated with the PRD are marked as either 'done' or 'deferred'.","If any tasks related to the PRD are found in states other than 'done' or 'deferred' (e.g., 'pending', 'in-progress', 'blocked'), the PRD closure process should NOT be initiated, and the user should be informed of the outstanding tasks.","After all other steps in the PRD closure process are successfully completed (including Git operations and GitHub issue closure), all Task Master tasks that were associated with the now-closed PRD should be removed from the system. This includes tasks that were marked 'done' and tasks that were marked 'deferred' as part of the PRD's scope.","To remove the tasks, their IDs will need to be identified (e.g., based on the initial PRD parsing or by a naming convention if applicable) and then the `mcp_taskmaster-ai_remove_task` tool should be used for each."]}
{"type":"entity","entityType":"DevelopmentProcessGuideline","name":"TemporaryPRDCleanupGuideline","observations":["After a PRD (Product Requirement Document) is closed or work on it is completed, any temporary local files created from1 or for that PRD should be removed.","This cleanup helps to prevent clutter and ensures that outdated temporary PRD information is not accidentally used.","Examples of temporary files include local text files generated from1 GitHub Issues, or intermediate files created during PRD processing."]}
{"type":"entity","name":"End Of Session Protocol","entityType":"Workflow Guideline","observations":["When the user indicates the session is complete (e.g., by saying 'We're done' or similar phrases), follow these steps:\n1.  **Cleanup Temporary Files:** Delete any temporary session-specific files. This includes, but is not limited to, temporary PRD markdown files (e.g., `scripts/prd*_temp.md`), all files matching the pattern `tasks/task*` (representing individual task files or session-specific task lists like `tasks/tasks-prdXXX.json`), and backup files (e.g., `*.bak`). **Confirm with the user if unsure about any file's temporary nature, especially broadly named task list files like `tasks/tasks.json` if it's intended to be persistent.**\n2.  **Branch and PR Creation:**\n    a.  Check the current git branch.\n    b.  If the current branch is `main` (or `master`):\n        i.  Create a new branch. Suggested naming: `feature/session-updates-YYYYMMDD-HHMMSS` or `feature/prd<ID>-<short-desc>`.\n        ii. Stage all changes (`git add .`).\n        iii. Commit the changes with a descriptive message (e.g., \"feat: Apply changes from session regarding PRD #XYZ\" or \"refactor: Updates from session on YYYY-MM-DD\").\n        iv. Push the new branch to the remote repository.\n    c.  Create a Pull Request (PR) targeting the `main` (or `master`) branch. Use a descriptive title and body, summarizing the changes.\n3.  **Review Process:**\n    a.  After the PR is created, inform the user that the PR is ready.\n    b.  **Attempt to fetch review status and comments using available tools. For GitHub, try commands like `gh pr view <PR_NUMBER_OR_URL> --comments` to see comments, and `gh pr checks <PR_BRANCH_NAME>` or `gh pr status --pr <PR_NUMBER_OR_URL>` (if `status` subcommand is available and provides review details) or `gh pr reviews <PR_NUMBER_OR_URL>` to get review information. Prioritize commands that give structured review status (approved, changes requested, commented).**\n    c.  **If direct review checking via tools is not possible, does not yield a clear review outcome (e.g., approved/rejected), or if a tool to interpret the output is unavailable, instruct the user to check the review status on the platform and provide the outcome** (e.g., 'positive', 'approved', 'needs changes').\n4.  **Post-Review Actions (If Review is Positive):**\n    a.  If the user reports a positive review outcome:\n        i.  **Pre-Merge Check:** On the local feature branch, run `git status` to check for any uncommitted changes. If there are uncommitted changes, stage and commit them, then push to the remote feature branch to update the PR. Wait for the user to confirm these latest changes are also reviewed and approved before proceeding with the merge.\n        ii. Merge the PR into the `main` (or `master`) branch (squash merge preferred using `gh pr merge <PR_NUMBER_OR_URL> --squash --delete-branch`).\n        iii. Delete the feature branch both locally (after switching to `main` and pulling) and from the remote repository (if not deleted by the merge command).\n    b.  If the review indicates changes are needed, inform the user and await further instructions for addressing the feedback.\n5.  **Confirmation:** Confirm completion of these steps to the user.","When the user indicates the session is complete (e.g., by saying 'We're done' or similar phrases), follow these steps:\\n1.  **Cleanup Temporary Files:** Delete any temporary session-specific files. This includes, but is not limited to, temporary PRD markdown files (e.g., `scripts/prd*_temp.md`), all files matching the pattern `tasks/task*` (representing individual task files or session-specific task lists like `tasks/tasks-prdXXX.json`), and backup files (e.g., `*.bak`). **Confirm with the user if unsure about any file's temporary nature, especially broadly named task list files like `tasks/tasks.json` if it's intended to be persistent.**\\n2.  **Branch and PR Creation:**\\n    a.  Check the current git branch.\\n    b.  If the current branch is `main` (or `master`):\\n        i.  Create a new branch. Suggested naming: `feature/session-updates-YYYYMMDD-HHMMSS` or `feature/prd<ID>-<short-desc>`.\\n        ii. Stage all changes (`git add .`).\\n        iii. Commit the changes with a descriptive message (e.g., \\\"feat: Apply changes from session regarding PRD #XYZ\\\" or \\\"refactor: Updates from session on YYYY-MM-DD\\\").\\n        iv. Push the new branch to the remote repository.\\n    c.  Create a Pull Request (PR) targeting the `main` (or `master`) branch. Use a descriptive title and body, summarizing the changes.\\n3.  **Review Process:**\\n    a.  After the PR is created, inform the user that the PR is ready.\\n    b.  **Attempt to fetch review status and comments using `github` MCP tools. For GitHub: use `mcp_github_get_pull_request_comments` for comments, `mcp_github_get_pull_request_reviews` for review status (approved, changes requested), and `mcp_github_get_pull_request_status` or `mcp_github_get_pull_request` for overall PR status and checks. Prioritize tools that give structured review outcomes.**\\n    c.  **If direct review checking via tools is not possible, does not yield a clear review outcome (e.g., approved/rejected), or if a tool to interpret the output is unavailable, instruct the user to check the review status on the platform and provide the outcome** (e.g., 'positive', 'approved', 'needs changes').\\n4.  **Post-Review Actions (If Review is Positive):**\\n    a.  If the user reports a positive review outcome:\\n        i.  **Pre-Merge Check:** On the local feature branch, run `git status` to check for any uncommitted changes. If there are uncommitted changes, stage and commit them, then push to the remote feature branch to update the PR. Wait for the user to confirm these latest changes are also reviewed and approved before proceeding with the merge.\\n        ii. Merge the PR into the `main` (or `master`) branch using `mcp_github_merge_pull_request`. Squash merge is preferred (set `merge_method: 'squash'`). The tool can also delete the head branch after merge if supported, otherwise, delete it manually via `git` CLI for local and `mcp_github_delete_branch` for remote if necessary.\\n        iii. Delete the feature branch both locally (after switching to `main` and pulling) and from the remote repository (if not deleted by the merge command and not handled by `mcp_github_merge_pull_request`).\\n    b.  If the review indicates changes are needed, inform the user and await further instructions for addressing the feedback.\\n5.  **Confirmation:** Confirm completion of these steps to the user."]}
{"type":"entity","observations":["Always push all modified files in the repository for commits, not just files directly edited during the current operation."],"entityType":"Development Guideline","name":"Commit and Push Scope"}
{"type":"entity","entityType":"Development Guideline","name":"Git and GitHub Operations Policy","observations":["For all remote GitHub operations (e.g., listing/creating/updating issues, pull requests, adding comments, fetching repository data), use the `github` MCP toolset.","For local Git repository management and pushing changes to the remote, use `git` CLI commands. This includes: creating local branches (e.g., `git checkout -b <branch-name>`), staging changes (`git add .`), committing changes (`git commit -m '...'`), and pushing commits (`git push`).","When creating a new branch that needs to exist on the remote repository, first create it locally (e.g., `git checkout -b <branch-name>`) and then push it to the remote setting the upstream tracking branch (e.g., `git push -u origin <branch-name>`)."]}
{"type":"entity","observations":["Upon user signals session completion (e.g., 'we're done', 'that's all'), agent MUST explicitly query memory for guidelines named 'EndOfSessionGitPushTrigger' or any other entities tagged with 'SessionCompletionProtocol' or 'EndOfSessionChecklist' before concluding the interaction or starting retroactive checks.","Upon user signals session completion (e.g., 'we're done', 'that's all'), agent MUST explicitly query memory for guidelines named 'PR Workflow and Completion Protocol', 'EndOfSessionGitPushTrigger', or any other entities tagged with 'SessionCompletionProtocol' or 'EndOfSessionChecklist' before concluding the interaction or starting retroactive checks.","When executing a multi-step guideline retrieved from memory, verbally confirm the completion or status of each step, even if a step results in no action or a modification to another guideline."],"entityType":"InternalProcessGuideline","name":"Agent Standard Operating Procedures"}
{"type":"entity","observations":["When a feature implementation is ready for PR: \n    - Ensure all local changes are committed to the feature branch (refer to 'Git and GitHub Operations Policy' for `git` CLI usage).\n    - Push the feature branch to the remote repository.\n    - Create a Pull Request against the `main` branch using the `github` MCP, detailing changes and linking to the relevant issue/PRD.","After PR creation:\n    - Request a GitHub Copilot review for the PR (or confirm if one is automatically triggered).\n    - Retrieve and review any automated code review feedback (e.g., GitHub Copilot comments).\n    - Address critical feedback by making necessary code changes, committing, and pushing to the feature branch. Create follow-up tasks/issues for non-critical feedback if not addressed immediately.","When the user indicates the overall work session for the feature/PR is done (e.g., 'We are done'):\n    - Initiate final checks and Git push (as per 'EndOfSessionGitPushTrigger' logic):\n        - Check `git status` for any uncommitted changes.\n        - If uncommitted changes exist (e.g., from addressing review feedback, or memory updates), confirm handling with the user (stage, commit, discard).\n        - If applicable, perform pre-push/pre-merge checks (e.g., `MandatoryDevboxBuildBeforeMain` if merging to main).\n        - Push any final local commits on the feature branch to the remote.\n    - Ensure all related project management tasks (e.g., Taskmaster tasks) are updated to reflect their final status (e.g., 'review', 'closed', or deleted if the PR fully supersedes them).\n    - Confirm with the user if any other wrap-up actions are needed."],"entityType":"DevelopmentProcessGuideline","name":"PR Workflow and Completion Protocol"}
{"type":"entity","name":"youtube-automation_owner","entityType":"GitHubRepositoryOwner","observations":["The owner of the youtube-automation GitHub repository is vfarcic."]}
{"type":"entity","entityType":"WorkflowGuideline","name":"GitPushWorkflowGuideline","observations":["When asked to push changes to a repository, always check for uncommitted local changes first using `git status --porcelain`. The user might have made changes manually outside of the AI's actions. If local changes exist, inform the user and ask if they want to commit and push them, or if they prefer to handle them manually."]}
{"type":"entity","name":"VfarcicYoutubeAutomationPushGuideline","observations":["The vfarcic/youtube-automation repository has a rule: 'Changes must be made through a pull request.' Direct pushes to the main branch will be rejected. When asked to push changes for this repository, the standard workflow is: 1. Create a new branch. 2. Commit changes to the new branch. 3. Push the new branch. 4. Create a pull request from the new branch to main. This should be the default procedure unless explicitly overridden by the user for a specific instance."],"entityType":"RepositorySpecificWorkflowGuideline"}
{"type":"entity","observations":["Always validate Nushell scripts after modifying them.","Validation should be done by executing the script with the relevant command and the `--help` flag.","For example, if a function `setup` inside `dot.nu` was modified, validate with `./dot.nu setup --help`."],"name":"Nushell Script Validation Guideline","entityType":"DevelopmentProcessGuideline"}
{"type":"entity","entityType":"DevelopmentGuideline","observations":["When in doubt about language features, syntax, or best practices for a specific technology (e.g., Nushell), consult the Context7 MCP for relevant documentation before proposing a solution."],"name":"Consult Context7 for Doubts"}
{"type":"entity","observations":["When fetching PRDs (GitHub Issues labeled 'PRD'), the `mcp_github_list_issues` tool SHOULD be used. Specify the 'PRD' label in the `labels` parameter.","To view details of a specific PRD (GitHub Issue), the `mcp_github_get_issue` tool SHOULD be used, providing the issue number.","If `gh` CLI is used as a fallback for fetching issues, prefix the command with `GH_PAGER=` to prevent output mangling (e.g., `GH_PAGER= gh issue list --label \\\"PRD\\\" --json ...`)."],"entityType":"DevelopmentProcessGuideline","name":"PRDFetchingGuideline"}
{"type":"entity","entityType":"DevelopmentProcessGuideline","observations":["After a Pull Request (PR) is successfully merged:","1. Switch the local Git repository to the `main` branch (or the primary integration branch).","2. Pull the latest changes from1 the remote repository to ensure the local `main` branch is up-to-date."],"name":"PostPRMergeWorkflow"}
{"type":"entity","entityType":"Guideline","observations":["Prioritize GitHub Issues as the single source of truth for Product Requirement Documents (PRDs) and their main tasks.","Avoid duplicating PRD content into local files (e.g., prd.txt) for long-term tracking or if the PRD is already in a GitHub Issue.","If a tool requires file input for a PRD already in a GitHub Issue, create the file ephemerally by copying content from1 the GitHub Issue, use it for the tool, and then delete the local file immediately.","When working on a PRD, select tasks directly from1 the GitHub Issue. Use Taskmaster tools (e.g., add_task, expand_task) to manage the execution of specific, individual tasks selected from1 the GitHub Issue, not by re-parsing an entire PRD from1 a local file if it's already in a GitHub Issue.","The `parse_prd` command is best used for initial ingestion of a new, file-based PRD that has not yet been structured or entered into GitHub Issues."],"name":"PRDManagementBestPractice"}
{"type":"entity","name":"PRD Development Workflow","entityType":"Guideline","observations":["Taskmaster MUST be used to generate tasks from1 a PRD before any implementation work begins."]}
{"type":"entity","entityType":"Guideline","observations":["After implementing a new feature or a change, always consider if a new, focused unit test can be added to specifically validate the core logic of that change, even if the broader existing test suite passes. This is especially important for configuration changes and new business logic.","If previous attempts at testing related functionality were complex, evaluate if a simpler, more targeted test is feasible for the new, specific piece of code before deferring testing entirely."],"name":"Unit Testing for New Changes"}
{"type":"entity","entityType":"Guideline","observations":["All relevant tests MUST be run and pass before changing the status of a Taskmaster task to 'done'."],"name":"Testing Before Task Completion"}
{"type":"entity","name":"PRDTextFileHandling","entityType":"DevelopmentProcessGuideline","observations":["PRD (Product Requirement Document) text files, often located in the `scripts/` directory and matching patterns like `prd_*.txt` or `prd_*.md`, are considered temporary local files.","These files are used for initial input into tools like Taskmaster to generate tasks.","They should NOT be committed to the Git repository.","Consider adding a pattern like `scripts/prd_*.txt` and `scripts/prd_*.md` to `.gitignore` to prevent accidental staging."]}
{"type":"relation","from":"YouTube Automation Tool","to":"Project Config","relationType":"uses"}
{"type":"relation","from":"YouTube Automation Tool","to":"Project Requirements","relationType":"requires"}
{"type":"relation","from":"Project","to":"YouTube Automation Tool","relationType":"is"}
{"type":"relation","from":"YouTube Automation Tool","to":"Charmbracelet Libraries","relationType":"uses for UI"}
{"type":"relation","to":"Taskmaster","relationType":"means user wants to work with","from":"Get PRDs"}
{"type":"relation","from":"Get PRDs","relationType":"means user wants to work with","to":"GitHub Issues with PRD label"}
{"type":"relation","to":"Taskmaster","from":"GitHub Issues with PRD label","relationType":"are used as PRDs for"}